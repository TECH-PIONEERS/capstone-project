# 0527

상위 회의: 5월 (5%E1%84%8B%E1%85%AF%E1%86%AF%20165e6d39028a4ac49db3079ac9ca14c8.md)

### 해결해야 할 문제

- [ ]  ⭐time.sleep main process 중단되는 문제⭐

---

1. tts_process 함수 안에서 라이브러리 import, utils 함수 및 변수 안 쓰도록 수정하고, 쓰레드 만들지 않고 프로세스 안에서 수행되도록 수정한 코드
    - 수정한 부분
    
    ```python
    def tts_process(tts_flag, dist):
        # 함수 안에서 라이브러리 import, utils 함수 및 변수 안 쓰도록
        import utils
        import time
        import pygame
        import pyttsx3
        from espeak import espeak
    
        #is_beeping = False
        current_dist = 0
        pygame.init()
        pygame.mixer.init()
        engine = pyttsx3.init('espeak')
    
        while True:
            current_flag = tts_flag.value
            current_dist = dist.value
    
            if current_flag == const.ball_missing:
                print("ball missing")
                beep_sound = pygame.mixer.Sound("sound/high_beep.wav")
                beep_sound.play()
                time.sleep(3)
            elif current_flag == const.ball_align_bottom:
                print("ball bottom")
                engine.say("Down") #TTS
                engine.runAndWait()
            elif current_flag == const.ball_align_up:
                print("ball up")
                engine.say("Up") #TTS
                engine.runAndWait() 
            elif current_flag == const.head_missing: #퍼터 값이 없을 경우
                print("head missing")
                beep_sound = pygame.mixer.Sound("sound/long_beep.wav")
                beep_sound.play()
                time.sleep(3)
            elif current_flag == const.head_align: #정렬 되지 않은 경우
                print("no head align")
                beep_sound = pygame.mixer.Sound("sound/low_beep.wav")
                beep_sound.play()
                time.sleep(3)
            elif current_flag == const.head_center_down:
                 print("head down")
                 engine.say("head Down") #TTS
                 engine.runAndWait()
            elif current_flag == const.head_center_up:
                 print("head up")            
                 engine.say("Head Up") #TTS
                 engine.runAndWait()
            elif current_dist > 0:
                 print(f"dist {current_dist}")
                 engine.say(str(current_dist)) #TTS
                 engine.runAndWait()
    ```
    

- 코드 위치: value_lock_code.py
    - tts_process 함수를 수정

1. 각 공유 변수에 대한 접근이 직렬화 되어 있는 상황일 수 있다. 즉, 한 프로세스가 공유 변수 중 하나에 접근할 때, 다른 프로세스는 그 접근이 끝날 때까지 기다려야 하는 상황이다. 
    - 우리가 사용하고 있는 **`Manager`** 는 내부적으로 락을 사용하여 데이터를 보호하기 때문에, 락을 관리할 필요가 없었다. 이 Manager.Namespace 내부에서 공유 변수 접근을 직렬화 하고 있었을 수 있다.
    - **`multiprocessing.Value`**를 사용하면 데이터를 직렬화하지 않고 공유할 수 있다. 그러나 내장된 동기화 기능이 제공되지 않으므로 데이터의 일관성을 유지하기 위해 사용자가 명시적으로 락(lock)을 사용해야 한다.
- **Value & lock**
    - **`lock=False`**를 설정하여 다른 프로세스가 기다리지 않고 즉시 공유 변수에 접근할 수 있다. 그러나 명시적으로 lock 구현해서 동기화를 관리해야 한다.
    
- 코드 위치: value_lock_code.py
    - tts_flag를 Value & lock으로 수정

- 코드 결과: 딜레이가 여전히 발생하는 것으로 보인다. 기존 코드 실행했을 때와 큰 차이를 발견하지 못하였다.