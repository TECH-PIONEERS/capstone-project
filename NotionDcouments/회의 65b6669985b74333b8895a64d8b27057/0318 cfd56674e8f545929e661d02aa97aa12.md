# 0318

상위 회의: 3월 (3%E1%84%8B%E1%85%AF%E1%86%AF%2044735b2f30df420e8cbf10cea8d03ced.md)

오늘 할일

- [x]  라즈베리파이 수령
- [x]  라즈베리파이 기본 설정 (OpenCV 설치)
    - venv
        
        ```jsx
        source .venv/bin/act음
        ```
        
- [ ]  모델링 → 이용할만한 자료 찾음
- [ ]  OpenCV 사용 코드 실행 및 테스트
    - 원본 코드: [https://diy-project.tistory.com/96](https://diy-project.tistory.com/96)
    - 로지텍 드라이버 설치
        
        링크: [https://support.logi.com/hc/ko/articles/360025141614-Logitech-Capture](https://support.logi.com/hc/ko/articles/360025141614-Logitech-Capture)
        
    - 공 인식 색깔 이슈 → 조명이 필요할 수도
        
        링크: [https://house-of-e.tistory.com/entry/10-OpenCV-python-색상-범위-추출-inRange](https://house-of-e.tistory.com/entry/10-OpenCV-python-%EC%83%89%EC%83%81-%EB%B2%94%EC%9C%84-%EC%B6%94%EC%B6%9C-inRange)
        
- [x]  다이소에서 골프 매트, 골프 공 구매

다음시간까지 할 일

- [ ]  OpenCV 개인 컴퓨터에 설치 및 골프공 인식 테스트 → 개발일지 작성하기

- 3D 프린터 장비 예약 링크: [http://makerspace.inu.ac.kr/index.php](http://makerspace.inu.ac.kr/index.php)
    - **3D 프린터 Dimension 1200es**
    
    | 빌드크기 | 254 x 254 x 305 mm(10 x 10 x 30.48 cm) |
    | --- | --- |
- 각자 컴퓨터에 설치:
    - **Autodesk 123D Design**
    - openCV

다이소 퍼팅 매트 : 200 X 20 cm

### 퍼팅 3D 모델링 자료

[Indoor Golf Putting Green Portable Mat 3D Model $29 - .3ds .blend .c4d .fbx .max .ma .lxo .obj - Free3D](https://free3d.com/3d-model/indoor-golf-putting-green-portable-mat-1531.html)

- opencv 분홍공
    
    ```python
    # import the necessary packages
    from collections import deque
    from imutils.video import VideoStream
    import numpy as np
    import argparse
    import cv2
    import imutils
    import time
    
    # construct the argument parse and parse the arguments
    ap = argparse.ArgumentParser()
    ap.add_argument("-v", "--video",
        help="path to the (optional) video file")
    ap.add_argument("-b", "--buffer", type=int, default=64,
        help="max buffer size")
    args = vars(ap.parse_args())
    
    # define the lower and upper boundaries of the "green"
    # ball in the HSV color space, then initialize the
    # list of tracked points
    #greenLower = (127, 119, 117) #686f77
    #greenUpper = (214, 190, 174)  #B2C2CA
    #greenUpper = (214, 190, 174)  #B2C2CA
    
    #greenLower = (104, 111, 119) #686f77
    #greenUpper = (178,194,202)  #B2C2CA
    #greenLower = (128, 128, 128)
    #greenUpper = (255, 255, 255)
    # greenLower = (29, 86, 6)
    # greenUpper = (64, 255, 255)
    # greenLower = (120, 29, 145)
    # greenUpper = (145, 29, 29)
    
    #greenLower = (97, 0, 102)
    ##greenLower = (255, 51, 51)
    ##greenUpper = (255, 51, 207)
    #greenUpper = (119, 51, 255)
    
    # greenLower = (191, 33, 75)
    # greenUpper = (255, 51, 207)
    
    greenLower = (168, 0, 76)
    greenUpper = (255, 192, 235)
    
    pts = deque(maxlen=args["buffer"])
        
    vs = cv2.VideoCapture(0)
    
    # allow the camera or video file to warm up
    time.sleep(2.0)
    
    # keep looping
    while True:
        # grab the current frame
        _, frame = vs.read()
        # handle the frame from VideoCapture or VideoStream
        # frame = frame[1] if args.get("video", False) else frame
    
        # if we are viewing a video and we did not grab a frame,
        # then we have reached the end of the video
        if frame is None:
            break
    
        # resize the frame, blur it, and convert it to the HSV
        # color space
        frame = imutils.resize(frame, width=600)
        blurred = cv2.GaussianBlur(frame, (11, 11), 0)
        hsv = cv2.cvtColor(blurred, cv2.COLOR_BGR2HSV)
        #print("**" + frame)
    
        # construct a mask for the color "green", then perform
        # a series of dilations and erosions to remove any small
        # blobs left in the mask
        mask = cv2.inRange(hsv, greenLower, greenUpper)
        mask = cv2.erode(mask, None, iterations=2)
        mask = cv2.dilate(mask, None, iterations=2)
    
        # find contours in the mask and initialize the current
        # (x, y) center of the ball
        cnts = cv2.findContours(mask.copy(), cv2.RETR_EXTERNAL,
            cv2.CHAIN_APPROX_SIMPLE)
        cnts = imutils.grab_contours(cnts)
        #cnts = cnts[0] if imutils.is_cv2() else cnts[1]
        center = None
        print(len(cnts))
    
        # only proceed if at least one contour was found
        if len(cnts) > 0:
            # find the largest contour in the mask, then use
            # it to compute the minimum enclosing circle and
            # centroid
            c = max(cnts, key=cv2.contourArea)
            ((x, y), radius) = cv2.minEnclosingCircle(c)
            M = cv2.moments(c)
            center = (int(M["m10"] / M["m00"]), int(M["m01"] / M["m00"]))
    
            # only proceed if the radius meets a minimum size
            if radius > 10:
                # draw the circle and centroid on the frame,
                # then update the list of tracked points
                cv2.circle(frame, (int(x), int(y)), int(radius),
                    (0, 255, 255), 2)
                cv2.circle(frame, center, 5, (0, 0, 255), -1)
    
        # update the points queue
        pts.appendleft(center)
    
        # loop over the set of tracked points
        for i in range(1, len(pts)):
            # if either of the tracked points are None, ignore
            # them
            if pts[i - 1] is None or pts[i] is None:
                continue
    
            # otherwise, compute the thickness of the line and
            # draw the connecting lines
            thickness = int(np.sqrt(args["buffer"] / float(i + 1)) * 2.5)
            cv2.line(frame, pts[i - 1], pts[i], (0, 0, 255), thickness)
        
        # show the frame to our screen
        cv2.imshow("Frame", frame)
        key = cv2.waitKey(1) & 0xFF
    
        # if the 'q' key is pressed, stop the loop
        if key == ord("q"):
            break
    
    # close all windows
    cv2.destroyAllWindows()
    ```